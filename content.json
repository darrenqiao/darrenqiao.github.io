{"meta":{"title":"Darren Qiao 的博客","subtitle":"去经历，去极致","description":null,"author":"Darren Qiao","url":"http://yoursite.com"},"pages":[{"title":"我的微信","date":"2018-09-21T15:07:10.000Z","updated":"2018-09-21T15:26:47.407Z","comments":true,"path":"qiaozp919/index.html","permalink":"http://yoursite.com/qiaozp919/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-21T08:43:43.000Z","updated":"2018-09-21T08:47:31.751Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"About me","date":"2018-09-21T08:42:45.000Z","updated":"2018-09-21T08:53:23.690Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Hey, about me, please stay tuned for more."},{"title":"tags","date":"2018-09-21T03:53:36.000Z","updated":"2018-09-21T04:06:29.077Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"关于String的知识点","slug":"关于String的知识点","date":"2018-10-03T10:32:07.000Z","updated":"2018-10-04T16:12:48.253Z","comments":true,"path":"2018/10/03/关于String的知识点/","link":"","permalink":"http://yoursite.com/2018/10/03/关于String的知识点/","excerpt":"","text":"String存在哪里？存在于堆和字符串常量池中 堆是通过new方法创建String对象是所存放的地方 字符串常量池是直接通过双引号定义String 字面量存放的地方，这块区域在Java 7之前存放在永久代中，Java 7之后是存放在堆空间中 Java 7 及以后字符串常量池也是存放在堆中，这种情况下还有什么区别吗？有区别，存放的方式不一样，永久代相对更容易产生OOM错误，而堆空间则有更频繁的垃圾回收机制 String长度有什么限制？ 在编译期(字符串常量池)中的长度限制是65534 作为常量池的一部分，使用CONSTANT_UTF8_info存放,其中的length限制是2字节 在运行期长度限制是2G public int length()返回值是int, int最大值就是2^31 - 1 String 对象用什么存的 Java 8 及以前采用char[],UTF-16编码 Java 9 中采用压缩字符串，根据存储的内容选择用char[] 还是byte[]存放","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"一道题目的思考","slug":"一道题目的思考","date":"2018-10-03T07:56:00.000Z","updated":"2018-10-03T10:33:32.083Z","comments":true,"path":"2018/10/03/一道题目的思考/","link":"","permalink":"http://yoursite.com/2018/10/03/一道题目的思考/","excerpt":"","text":"题目如何实现，在泛型为Integer的ArrayList中存放一个String类型的对象。 解答通过反射在运行时传入String对象12345678private static void testGenericsAndReflection() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;(); //通过反射获取方法并添加String对象 Class&lt;? extends List&gt; aClass = integerList.getClass(); Method addMethod = aClass.getMethod( \"add\", Object.class ); addMethod.invoke( integerList, \"darrenqiao\" ); System.out.println( \"darrenqiao\".equals( integerList.get( 0 ) ) ); &#125; 为什么因为泛型在编译阶段会进行强类型检查，知道这个特性之后又什么办法呢？想想在运行时怎么动态添加，很自然的想到Java的核心特性 反射，可以在反射时动态的加入不同的类型。 思考 学好，学深，并灵活利用 Java基础特性是个技术活，也是很有必要的，便于解决各种刁钻的问题。 很多框架，组件技术都是基于基础特性封装之上的最佳实践。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"Java IO - 概述","slug":"Java-IO-概述","date":"2018-09-27T12:57:53.000Z","updated":"2018-10-05T12:22:39.792Z","comments":true,"path":"2018/09/27/Java-IO-概述/","link":"","permalink":"http://yoursite.com/2018/09/27/Java-IO-概述/","excerpt":"","text":"Java IO是由JavaSE提供的API接口，主要目的是用于读写数据。功能主要集中于 java.io(同步阻塞实现)，java.nio(异步阻塞实现)和java.nio2(异步非阻塞实现)三个包中,这个系列主要讲java.io。 首先，IO处理涉及到一下几个基本概念， 数据IO的抽象形式 流，是Java IO中数据存在和传输的格式，表示一组有序的，单向的，有起点，有终点的集合。 对流的处理方式 按照字节读取 -&gt; InputStream / OutputStream 按照字符读取 -&gt; Reader / Writer 按照数据来源划分其中，Filter是用来对数据进行一定的过滤处理，官方提供了几种过滤方式 为输入的数据增加一层缓存以提高性能 Buffer将数据直接转成Java基本数据类型,存的时候是转换成二进制 DataInputStream/DataOutputStream123try (DataOutputStream dataOutputStream = new DataOutputStream( new FileOutputStream( \"data.txt\" ) )) &#123; dataOutputStream.writeBoolean( true );&#125; 打印任意数据类型,转换成字符串，主要用于展示信息 PrintStream1234try (PrintStream printStream = new PrintStream( \"data.txt\" )) &#123; printStream.print( true ); printStream.print( \"darrenqiao\" );&#125; 读取数据的时候允许回退几个字节 PushbackInputStream1234PushbackInputStream input = new PushbackInputStream( new FileInputStream(\"c:\\\\data\\\\input.txt\"));int data = input.read();input.unread(data); SequenceInputStream 的作用是支持从多个输入流中读取数据123456Vector&lt;InputStream&gt; vector = new Vector&lt;InputStream&gt;();vector.addElement(new FileInputStream(\"D:\\\\text1.txt\"));vector.addElement(new FileInputStream(\"D:\\\\text2.txt\"));Enumeration&lt;InputStream&gt; e = vector.elements();SequenceInputStream sequenceInputStream = new SequenceInputStream(e); 举例 两个进程之间通过管道传输数据传输数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.io.IOException;import java.io.PipedReader;import java.io.PipedWriter;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * Created by darrenqiao on 10/5/2018. */public class TestPipedIO &#123; public static void main(String[] args) throws IOException, InterruptedException &#123; testPipedStream(); &#125; // define static fields to share between threads final static PipedReader pipedReader = new PipedReader(); final static PipedWriter pipedWriter = new PipedWriter(); private static void testPipedStream() throws IOException, InterruptedException &#123; Thread threadWriter = new Thread( new Runnable() &#123; @Override public void run() &#123; for (int i = 1; i &lt;= 5; ++i) &#123; try &#123; //write thread pipedWriter.write( i ); Thread.sleep( 1000 ); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; ); Thread threadReader = new Thread( new Runnable() &#123; @Override public void run() &#123; int read = 0; try &#123; // read thread while ((read = pipedReader.read()) != -1) &#123; System.out.println( \"message from pipedWriter is : \" + read ); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; ); pipedReader.connect( pipedWriter ); ExecutorService executorService = Executors.newFixedThreadPool( 2 ); executorService.execute( threadReader ); executorService.execute( threadWriter ); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java IO","slug":"Java-IO","permalink":"http://yoursite.com/tags/Java-IO/"}]},{"title":"JVM类文件中的常量池","slug":"JVM类文件中的常量池","date":"2018-09-21T18:53:49.000Z","updated":"2018-10-04T12:05:00.405Z","comments":true,"path":"2018/09/21/JVM类文件中的常量池/","link":"","permalink":"http://yoursite.com/2018/09/21/JVM类文件中的常量池/","excerpt":"","text":"是什么是class文件中特殊格式字节的集合 有什么作用主要用来存放两大类常量：字面量 和 符号引用。由Java 类加载器进行加载。 字面量包括以下几种： 文本字符串8大基本数据类型final修饰的常量 符号引用包含以下几种： 类和接口的全限定名子段的名称和描述符方法的名称和描述符 基本组成是什么常量池的每一个常量都是一个表结构，由以下14个基本表结构组成 八大基本数据类型中 boolean, byte, short, int, char 都对应的是 CONSTANT_Integer_info 字段 上面的每一个类型都是一个表结构，至少包含两个字段，比如 CONSTANT_Class_info结构如下： 类型 名称 数量 u1 tag 1 u2 name_index 1 tag 就是CONSTANT_Class_info对应的标志位7name_index 是一个索引值，因为这里需要的是类或者接口的全限定名，所以会指向一个CONSTANT_Utf8_info结构 变量，方法名最长多长，为什么？最长65535，即64KB，因为变量，方法名都是在CONSTANT_Utf8_info中存放，该结构有三个字段： 类型 名称 数量 u1 tag 1 u2 length 1 u1 bytes length lengh表示的是名称的长度，u2表示的是两个字节的无符号整数，最大值为65535. 代码中怎么体现出来写一个简单的例子123456789101112131415/** * FileName : TestConstantPool.java * Created by zongpengq on 9/21/2018. */public class TestConstantPool &#123; static int intData; static boolean ifData; static char charData; public static void main(String[] args) &#123; intData = 12; ifData = false; charData = 'a'; &#125;&#125; 用 javac TestConstantPool.java 得到字节码文件 TestConstantPool.class，再通过 javap -v TestConstantPool.class 可以看到代码对应的常量池部分 反编译之后发现有这段代码编译之后常量池中放有26个常量类型，简单取其中#1解释一下 #1 常量类型是 Methodref表示是一个类方法索引常量，用来描述Object的\\方法，由类索引信息#6 和 方法索引信息 #21组成#6 是Class类型，指向Obejct类，所以的全限定名又存放到 #26 Utf8类型中#21 是NameAndType类型用来描述方法#13 和方法描述符信息#14#14 用()V表示函数返回值为void","categories":[{"name":"JVM虚拟机","slug":"JVM虚拟机","permalink":"http://yoursite.com/categories/JVM虚拟机/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"网站的创建过程","slug":"网站的创建过程","date":"2018-09-20T14:03:37.000Z","updated":"2018-10-03T08:20:48.728Z","comments":true,"path":"2018/09/20/网站的创建过程/","link":"","permalink":"http://yoursite.com/2018/09/20/网站的创建过程/","excerpt":"","text":"基本过程 呈现的内容放在github上，需要创建账户，创建个人repo 通过hexo实现本次博客环境的管理，并完成和repo的交互 自定义相关博客页面 将github.io的网址和自己购买的域名绑定 COURTESY OF 基于hexo和github搭建个人博客关于归档等设置增加评论功能和域名绑定解决网站在chrome上一直显示不安全增加阅读数量功能","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"http://yoursite.com/categories/杂七杂八/"}],"tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"http://yoursite.com/tags/杂七杂八/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-09-20T12:05:41.400Z","updated":"2018-09-21T08:54:44.645Z","comments":true,"path":"2018/09/20/hello-world/","link":"","permalink":"http://yoursite.com/2018/09/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"http://yoursite.com/categories/杂七杂八/"}],"tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"http://yoursite.com/tags/杂七杂八/"}]}]}