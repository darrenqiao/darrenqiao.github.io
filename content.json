{"meta":{"title":"Darren Qiao 的博客","subtitle":"去经历，去极致","description":null,"author":"Darren Qiao","url":"http://www.darrenqiao.cn"},"pages":[{"title":"categories","date":"2018-09-21T08:43:43.000Z","updated":"2018-09-21T08:47:31.751Z","comments":true,"path":"categories/index.html","permalink":"http://www.darrenqiao.cn/categories/index.html","excerpt":"","text":""},{"title":"About me","date":"2018-09-21T08:42:45.000Z","updated":"2018-09-21T08:53:23.690Z","comments":true,"path":"about/index.html","permalink":"http://www.darrenqiao.cn/about/index.html","excerpt":"","text":"Hey, about me, please stay tuned for more."},{"title":"tags","date":"2018-09-21T03:53:36.000Z","updated":"2018-09-21T04:06:29.077Z","comments":true,"path":"tags/index.html","permalink":"http://www.darrenqiao.cn/tags/index.html","excerpt":"","text":""},{"title":"我的微信","date":"2018-09-21T15:07:10.000Z","updated":"2018-09-21T15:26:47.407Z","comments":true,"path":"qiaozp919/index.html","permalink":"http://www.darrenqiao.cn/qiaozp919/index.html","excerpt":"","text":""}],"posts":[{"title":"Java Stream API","slug":"Java-Stream-API","date":"2018-10-07T11:40:49.000Z","updated":"2018-10-09T12:13:34.969Z","comments":true,"path":"2018/10/07/Java-Stream-API/","link":"","permalink":"http://www.darrenqiao.cn/2018/10/07/Java-Stream-API/","excerpt":"","text":"有什么作用是对集合对象的功能增强，能够更加便利高效的进行聚合，批量数据操作，从Java 8 引入。 直观理解实现一个例子：打印List集合中包含子字符串 “darrenqiao”的元素。不使用Stream API12345for (String s : stringList) &#123; if (s.contains( \"darrenqiao\" )) &#123; System.out.println(s); &#125;&#125; 使用Stream API1234//一行代码搞定stringList.stream() .filter( item -&gt; item.contains( \"darrenqiao\" ) ) .forEach( System.out::println ) ; 组成部分通过上面的例子可以看出，主要由三个部分组成：Stream, Intermediate, Terminal。 Stream部分取得集合对象的数据集。Intermediate部分是一系列的中间操作，负责对数据集进行过滤，检索等在处理。Terminal部分是最终对经过一系列处理之后的数据进行几种的元素处理。 Stream部分什么是Stream是原数据的一种视图，一个序列化的元素集，支持序列化的聚合操作和并行的聚合操作。Stream不保存数据，只是基于原始集合/数组数据生成一个流水线的数据。比如上面的stringList.stream()就是基于原来的List生成一个流水线的数据集，供后续的filter，forEach操作。 *有什么特点 惰性执行：stream上的操作不会立即执行，只有等到用户真正需要结果(terminal operation)的时候才会执行。把所有中间操作积攒的操作以pipeline的形式执行。 无存储：基于数据源操作生成的序列 不会变动原始数据源 Intermediate部分skip ：跳过几个元素sorted ： 排序parallel ：并发执行sequential ：序列化执行，和并发执行对应distinct ： 保证元素集的唯一性。filter ：通过Lambda表达式进行过滤(上面的例子就是将是含有”darrenqiao”作为过滤条件)map ： 通过元素类型中的引用函数，将元素做映射，返回仍然是一个值。12345//我希望打印符合条件的字符串的长度stringList.stream() .filter( item -&gt; item.contains( \"darrenqiao\" ) ) .map( String::length )//在这里调用String类型的length()函数 .forEach( System.out::println ) ; flatmap : 相对于map可以返回多个值，并将多个值形成新的流。 简单来说就是把原Stream中所有元素摊平之后组成新的Stream。limit : 返回限定个数的元素。peek ： 返回原来的Stream，而外的在每个元素上执行一个操作。(可以用于debug日志打印)123456Stream.of( \"one\", \"two\", \"three\", \"four\" ) .filter( e -&gt; e.length() &gt; 3 ) .peek( e -&gt; System.out.println( \"Filtered value: \" + e ) ) .map( String::toUpperCase ) .peek( e -&gt; System.out.println( \"Mapped value: \" + e ) ) .collect( Collectors.toList() ); Terminal部分forEach : 对流中的每一个元素执行操作。findAny ：返回任意元素。allMatch : 判断是否所有元素匹配。anyMatch : 判断是否有一个元素匹配。collect : 返回所有元素集合。count : 返回所有元素个数。findFirst : 返回所有元素第一个。forEachOrdered : 按照原有的序列顺序输出。max : 返回所有元素最大值。min : 返回所有元素最小值。noneMatch : 判断是否全部不匹配。reduce :从一组元素中生成一个值。123456789101112//求解最长的一个字符串Stream&lt;String&gt; stream = Stream.of(\"I\", \"love\", \"you\", \"too\");Optional&lt;String&gt; longest = stream.reduce((s1, s2) -&gt; s1.length()&gt;=s2.length() ? s1 : s2);System.out.println(longest.get());//--------------------------------// 求单词长度之和Stream&lt;String&gt; stream = Stream.of(\"I\", \"love\", \"you\", \"too\");Integer lengthSum = stream.reduce(0, // 初始值 // (1) (sum, str) -&gt; sum+str.length(), // 累加器 // (2) (a, b) -&gt; a+b); // 部分和拼接器，并行执行时才会用到 // (3)// int lengthSum = stream.mapToInt(str -&gt; str.length()).sum();System.out.println(lengthSum); toArray : 返回数组。","categories":[],"tags":[]},{"title":"关于String的知识点","slug":"关于String的知识点","date":"2018-10-03T10:32:07.000Z","updated":"2018-10-04T16:12:48.253Z","comments":true,"path":"2018/10/03/关于String的知识点/","link":"","permalink":"http://www.darrenqiao.cn/2018/10/03/关于String的知识点/","excerpt":"","text":"String存在哪里？存在于堆和字符串常量池中 堆是通过new方法创建String对象是所存放的地方 字符串常量池是直接通过双引号定义String 字面量存放的地方，这块区域在Java 7之前存放在永久代中，Java 7之后是存放在堆空间中 Java 7 及以后字符串常量池也是存放在堆中，这种情况下还有什么区别吗？有区别，存放的方式不一样，永久代相对更容易产生OOM错误，而堆空间则有更频繁的垃圾回收机制 String长度有什么限制？ 在编译期(字符串常量池)中的长度限制是65534 作为常量池的一部分，使用CONSTANT_UTF8_info存放,其中的length限制是2字节 在运行期长度限制是2G public int length()返回值是int, int最大值就是2^31 - 1 String 对象用什么存的 Java 8 及以前采用char[],UTF-16编码 Java 9 中采用压缩字符串，根据存储的内容选择用char[] 还是byte[]存放","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.darrenqiao.cn/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.darrenqiao.cn/tags/面试题/"}]},{"title":"一道题目的思考","slug":"一道题目的思考","date":"2018-10-03T07:56:00.000Z","updated":"2018-10-03T10:33:32.083Z","comments":true,"path":"2018/10/03/一道题目的思考/","link":"","permalink":"http://www.darrenqiao.cn/2018/10/03/一道题目的思考/","excerpt":"","text":"题目如何实现，在泛型为Integer的ArrayList中存放一个String类型的对象。 解答通过反射在运行时传入String对象12345678private static void testGenericsAndReflection() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;(); //通过反射获取方法并添加String对象 Class&lt;? extends List&gt; aClass = integerList.getClass(); Method addMethod = aClass.getMethod( \"add\", Object.class ); addMethod.invoke( integerList, \"darrenqiao\" ); System.out.println( \"darrenqiao\".equals( integerList.get( 0 ) ) ); &#125; 为什么因为泛型在编译阶段会进行强类型检查，知道这个特性之后又什么办法呢？想想在运行时怎么动态添加，很自然的想到Java的核心特性 反射，可以在反射时动态的加入不同的类型。 思考 学好，学深，并灵活利用 Java基础特性是个技术活，也是很有必要的，便于解决各种刁钻的问题。 很多框架，组件技术都是基于基础特性封装之上的最佳实践。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.darrenqiao.cn/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://www.darrenqiao.cn/tags/面试题/"}]},{"title":"Java IO - 概述","slug":"Java-IO-概述","date":"2018-09-27T12:57:53.000Z","updated":"2018-10-05T12:22:39.792Z","comments":true,"path":"2018/09/27/Java-IO-概述/","link":"","permalink":"http://www.darrenqiao.cn/2018/09/27/Java-IO-概述/","excerpt":"","text":"Java IO是由JavaSE提供的API接口，主要目的是用于读写数据。功能主要集中于 java.io(同步阻塞实现)，java.nio(异步阻塞实现)和java.nio2(异步非阻塞实现)三个包中,这个系列主要讲java.io。 首先，IO处理涉及到一下几个基本概念， 数据IO的抽象形式 流，是Java IO中数据存在和传输的格式，表示一组有序的，单向的，有起点，有终点的集合。 对流的处理方式 按照字节读取 -&gt; InputStream / OutputStream 按照字符读取 -&gt; Reader / Writer 按照数据来源划分其中，Filter是用来对数据进行一定的过滤处理，官方提供了几种过滤方式 为输入的数据增加一层缓存以提高性能 Buffer将数据直接转成Java基本数据类型,存的时候是转换成二进制 DataInputStream/DataOutputStream123try (DataOutputStream dataOutputStream = new DataOutputStream( new FileOutputStream( \"data.txt\" ) )) &#123; dataOutputStream.writeBoolean( true );&#125; 打印任意数据类型,转换成字符串，主要用于展示信息 PrintStream1234try (PrintStream printStream = new PrintStream( \"data.txt\" )) &#123; printStream.print( true ); printStream.print( \"darrenqiao\" );&#125; 读取数据的时候允许回退几个字节 PushbackInputStream1234PushbackInputStream input = new PushbackInputStream( new FileInputStream(\"c:\\\\data\\\\input.txt\"));int data = input.read();input.unread(data); SequenceInputStream 的作用是支持从多个输入流中读取数据123456Vector&lt;InputStream&gt; vector = new Vector&lt;InputStream&gt;();vector.addElement(new FileInputStream(\"D:\\\\text1.txt\"));vector.addElement(new FileInputStream(\"D:\\\\text2.txt\"));Enumeration&lt;InputStream&gt; e = vector.elements();SequenceInputStream sequenceInputStream = new SequenceInputStream(e); 举例 两个进程之间通过管道传输数据传输数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.io.IOException;import java.io.PipedReader;import java.io.PipedWriter;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * Created by darrenqiao on 10/5/2018. */public class TestPipedIO &#123; public static void main(String[] args) throws IOException, InterruptedException &#123; testPipedStream(); &#125; // define static fields to share between threads final static PipedReader pipedReader = new PipedReader(); final static PipedWriter pipedWriter = new PipedWriter(); private static void testPipedStream() throws IOException, InterruptedException &#123; Thread threadWriter = new Thread( new Runnable() &#123; @Override public void run() &#123; for (int i = 1; i &lt;= 5; ++i) &#123; try &#123; //write thread pipedWriter.write( i ); Thread.sleep( 1000 ); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; ); Thread threadReader = new Thread( new Runnable() &#123; @Override public void run() &#123; int read = 0; try &#123; // read thread while ((read = pipedReader.read()) != -1) &#123; System.out.println( \"message from pipedWriter is : \" + read ); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; ); pipedReader.connect( pipedWriter ); ExecutorService executorService = Executors.newFixedThreadPool( 2 ); executorService.execute( threadReader ); executorService.execute( threadWriter ); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.darrenqiao.cn/categories/Java/"}],"tags":[{"name":"Java IO","slug":"Java-IO","permalink":"http://www.darrenqiao.cn/tags/Java-IO/"}]},{"title":"JVM类文件中的常量池","slug":"JVM类文件中的常量池","date":"2018-09-21T18:53:49.000Z","updated":"2018-10-04T12:05:00.405Z","comments":true,"path":"2018/09/21/JVM类文件中的常量池/","link":"","permalink":"http://www.darrenqiao.cn/2018/09/21/JVM类文件中的常量池/","excerpt":"","text":"是什么是class文件中特殊格式字节的集合 有什么作用主要用来存放两大类常量：字面量 和 符号引用。由Java 类加载器进行加载。 字面量包括以下几种： 文本字符串8大基本数据类型final修饰的常量 符号引用包含以下几种： 类和接口的全限定名子段的名称和描述符方法的名称和描述符 基本组成是什么常量池的每一个常量都是一个表结构，由以下14个基本表结构组成 八大基本数据类型中 boolean, byte, short, int, char 都对应的是 CONSTANT_Integer_info 字段 上面的每一个类型都是一个表结构，至少包含两个字段，比如 CONSTANT_Class_info结构如下： 类型 名称 数量 u1 tag 1 u2 name_index 1 tag 就是CONSTANT_Class_info对应的标志位7name_index 是一个索引值，因为这里需要的是类或者接口的全限定名，所以会指向一个CONSTANT_Utf8_info结构 变量，方法名最长多长，为什么？最长65535，即64KB，因为变量，方法名都是在CONSTANT_Utf8_info中存放，该结构有三个字段： 类型 名称 数量 u1 tag 1 u2 length 1 u1 bytes length lengh表示的是名称的长度，u2表示的是两个字节的无符号整数，最大值为65535. 代码中怎么体现出来写一个简单的例子123456789101112131415/** * FileName : TestConstantPool.java * Created by zongpengq on 9/21/2018. */public class TestConstantPool &#123; static int intData; static boolean ifData; static char charData; public static void main(String[] args) &#123; intData = 12; ifData = false; charData = 'a'; &#125;&#125; 用 javac TestConstantPool.java 得到字节码文件 TestConstantPool.class，再通过 javap -v TestConstantPool.class 可以看到代码对应的常量池部分 反编译之后发现有这段代码编译之后常量池中放有26个常量类型，简单取其中#1解释一下 #1 常量类型是 Methodref表示是一个类方法索引常量，用来描述Object的\\方法，由类索引信息#6 和 方法索引信息 #21组成#6 是Class类型，指向Obejct类，所以的全限定名又存放到 #26 Utf8类型中#21 是NameAndType类型用来描述方法#13 和方法描述符信息#14#14 用()V表示函数返回值为void","categories":[{"name":"JVM虚拟机","slug":"JVM虚拟机","permalink":"http://www.darrenqiao.cn/categories/JVM虚拟机/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.darrenqiao.cn/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"http://www.darrenqiao.cn/tags/Java/"}]},{"title":"网站的创建过程","slug":"网站的创建过程","date":"2018-09-20T14:03:37.000Z","updated":"2018-10-03T08:20:48.728Z","comments":true,"path":"2018/09/20/网站的创建过程/","link":"","permalink":"http://www.darrenqiao.cn/2018/09/20/网站的创建过程/","excerpt":"","text":"基本过程 呈现的内容放在github上，需要创建账户，创建个人repo 通过hexo实现本次博客环境的管理，并完成和repo的交互 自定义相关博客页面 将github.io的网址和自己购买的域名绑定 COURTESY OF 基于hexo和github搭建个人博客关于归档等设置增加评论功能和域名绑定解决网站在chrome上一直显示不安全增加阅读数量功能","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"http://www.darrenqiao.cn/categories/杂七杂八/"}],"tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"http://www.darrenqiao.cn/tags/杂七杂八/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-09-20T12:05:41.400Z","updated":"2018-09-21T08:54:44.645Z","comments":true,"path":"2018/09/20/hello-world/","link":"","permalink":"http://www.darrenqiao.cn/2018/09/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"http://www.darrenqiao.cn/categories/杂七杂八/"}],"tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"http://www.darrenqiao.cn/tags/杂七杂八/"}]}]}